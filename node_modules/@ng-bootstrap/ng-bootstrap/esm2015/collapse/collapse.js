import { Directive, ElementRef, EventEmitter, Input, NgZone, Output, } from '@angular/core';
import { ngbRunTransition } from '../util/transition/ngbTransition';
import { ngbCollapsingTransition } from '../util/transition/ngbCollapseTransition';
import { NgbCollapseConfig } from './collapse-config';
/**
 * A directive to provide a simple way of hiding and showing elements on the page.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './collapse-config';
export class NgbCollapse {
    constructor(_element, config, _zone) {
        this._element = _element;
        this._zone = _zone;
        /**
         * If `true`, will collapse the element or show it otherwise.
         */
        this.collapsed = false;
        this.ngbCollapseChange = new EventEmitter();
        /**
         * An event emitted when the collapse element is shown, after the transition. It has no payload.
         *
         * @since 8.0.0
         */
        this.shown = new EventEmitter();
        /**
         * An event emitted when the collapse element is hidden, after the transition. It has no payload.
         *
         * @since 8.0.0
         */
        this.hidden = new EventEmitter();
        this.animation = config.animation;
    }
    ngOnInit() { this._runTransition(this.collapsed, false); }
    ngOnChanges({ collapsed }) {
        if (!collapsed.firstChange) {
            this._runTransitionWithEvents(this.collapsed, this.animation);
        }
    }
    /**
     * Triggers collapsing programmatically.
     *
     * If there is a collapsing transition running already, it will be reversed.
     * If the animations are turned off this happens synchronously.
     *
     * @since 8.0.0
     */
    toggle(open = this.collapsed) {
        this.collapsed = !open;
        this.ngbCollapseChange.next(this.collapsed);
        this._runTransitionWithEvents(this.collapsed, this.animation);
    }
    _runTransition(collapsed, animation) {
        return ngbRunTransition(this._zone, this._element.nativeElement, ngbCollapsingTransition, { animation, runningTransition: 'stop', context: { direction: collapsed ? 'hide' : 'show' } });
    }
    _runTransitionWithEvents(collapsed, animation) {
        this._runTransition(collapsed, animation).subscribe(() => {
            if (collapsed) {
                this.hidden.emit();
            }
            else {
                this.shown.emit();
            }
        });
    }
}
NgbCollapse.ɵfac = function NgbCollapse_Factory(t) { return new (t || NgbCollapse)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgbCollapseConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NgbCollapse.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbCollapse, selectors: [["", "ngbCollapse", ""]], inputs: { collapsed: ["ngbCollapse", "collapsed"], animation: "animation" }, outputs: { ngbCollapseChange: "ngbCollapseChange", shown: "shown", hidden: "hidden" }, exportAs: ["ngbCollapse"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NgbCollapse.ctorParameters = () => [
    { type: ElementRef },
    { type: NgbCollapseConfig },
    { type: NgZone }
];
NgbCollapse.propDecorators = {
    animation: [{ type: Input }],
    collapsed: [{ type: Input, args: ['ngbCollapse',] }],
    ngbCollapseChange: [{ type: Output }],
    shown: [{ type: Output }],
    hidden: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgbCollapse, [{
        type: Directive,
        args: [{ selector: '[ngbCollapse]', exportAs: 'ngbCollapse' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.NgbCollapseConfig }, { type: ɵngcc0.NgZone }]; }, { collapsed: [{
            type: Input,
            args: ['ngbCollapse']
        }], ngbCollapseChange: [{
            type: Output
        }], shown: [{
            type: Output
        }], hidden: [{
            type: Output
        }], animation: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGFwc2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb2xsYXBzZS9jb2xsYXBzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFHTixNQUFNLEdBRVAsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFDbEUsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sMENBQTBDLENBQUM7QUFDakYsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQ7QUFBSTtBQUM4RSxHQUMvRTs7O0FBRUgsTUFBTSxPQUFPLFdBQVc7QUFBRyxJQWlDekIsWUFBb0IsUUFBb0IsRUFBRSxNQUF5QixFQUFVLEtBQWE7QUFBSSxRQUExRSxhQUFRLEdBQVIsUUFBUSxDQUFZO0FBQUMsUUFBb0MsVUFBSyxHQUFMLEtBQUssQ0FBUTtBQUFDLFFBdEIzRjtBQUFJO0FBRUYsV0FBQztBQUFDLFFBQ2tCLGNBQVMsR0FBRyxLQUFLLENBQUM7QUFBQyxRQUUvQixzQkFBaUIsR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO0FBQUMsUUFFM0Q7QUFBSTtBQUVGO0FBQ0s7QUFFRixXQURGO0FBQUMsUUFDTSxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztBQUFDLFFBRTVDO0FBQUk7QUFFRjtBQUNLO0FBRUYsV0FERjtBQUFDLFFBQ00sV0FBTSxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7QUFBQyxRQUkzQyxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFBQyxJQUNyQyxDQUFDO0FBQUMsSUFFRixRQUFRLEtBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUFDLElBRTNELFdBQVcsQ0FBQyxFQUFDLFNBQVMsRUFBZ0I7QUFBSSxRQUN4QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRTtBQUFFLFlBQzVCLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUFDLFNBQ2hFO0FBQUMsSUFDSixDQUFDO0FBQUMsSUFFRjtBQUFJO0FBRU47QUFDQztBQUNDO0FBQ0M7QUFDQztBQUNDLE9BQUE7QUFBQyxJQUNKLE1BQU0sQ0FBQyxPQUFnQixJQUFJLENBQUMsU0FBUztBQUFJLFFBQ3ZDLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFBQyxRQUN4QixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUFDLFFBQzdDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUFDLElBQ2pFLENBQUM7QUFBQyxJQUVNLGNBQWMsQ0FBQyxTQUFrQixFQUFFLFNBQWtCO0FBQUksUUFDL0QsT0FBTyxnQkFBZ0IsQ0FDbkIsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSx1QkFBdUIsRUFDaEUsRUFBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFDLEVBQUMsQ0FBQyxDQUFDO0FBQUMsSUFDbEcsQ0FBQztBQUFDLElBRU0sd0JBQXdCLENBQUMsU0FBa0IsRUFBRSxTQUFrQjtBQUFJLFFBQ3pFLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7QUFBRyxZQUMxRCxJQUFJLFNBQVMsRUFBRTtBQUFFLGdCQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7QUFBQyxhQUNyQjtBQUFDLGlCQUFLO0FBQUUsZ0JBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUFDLGFBQ3BCO0FBQUMsUUFDSixDQUFDLENBQUMsQ0FBQztBQUFDLElBQ04sQ0FBQztBQUFDO3VDQTFFSCxTQUFTLFNBQUMsRUFBQyxRQUFRLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUM7aVZBQzNEO0FBQUM7QUFBcUMsWUFqQnhDLFVBQVU7QUFDWCxZQVVPLGlCQUFpQjtBQUFJLFlBUjNCLE1BQU07QUFDUjtBQUFHO0FBRU0sd0JBb0JOLEtBQUs7QUFBSyx3QkFLVixLQUFLLFNBQUMsYUFBYTtBQUFPLGdDQUUxQixNQUFNO0FBQUssb0JBT1gsTUFBTTtBQUFLLHFCQU9YLE1BQU07QUFBSTs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBOZ1pvbmUsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtuZ2JSdW5UcmFuc2l0aW9ufSBmcm9tICcuLi91dGlsL3RyYW5zaXRpb24vbmdiVHJhbnNpdGlvbic7XHJcbmltcG9ydCB7bmdiQ29sbGFwc2luZ1RyYW5zaXRpb259IGZyb20gJy4uL3V0aWwvdHJhbnNpdGlvbi9uZ2JDb2xsYXBzZVRyYW5zaXRpb24nO1xyXG5pbXBvcnQge05nYkNvbGxhcHNlQ29uZmlnfSBmcm9tICcuL2NvbGxhcHNlLWNvbmZpZyc7XHJcblxyXG4vKipcclxuICogQSBkaXJlY3RpdmUgdG8gcHJvdmlkZSBhIHNpbXBsZSB3YXkgb2YgaGlkaW5nIGFuZCBzaG93aW5nIGVsZW1lbnRzIG9uIHRoZSBwYWdlLlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbbmdiQ29sbGFwc2VdJywgZXhwb3J0QXM6ICduZ2JDb2xsYXBzZSd9KVxyXG5leHBvcnQgY2xhc3MgTmdiQ29sbGFwc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XHJcbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCBjb2xsYXBzZSB3aWxsIGJlIGFuaW1hdGVkLlxyXG4gICAqXHJcbiAgICogQW5pbWF0aW9uIGlzIHRyaWdnZXJlZCBvbmx5IHdoZW4gY2xpY2tlZCBvbiB0cmlnZ2VyaW5nIGVsZW1lbnRcclxuICAgKiBvciB2aWEgdGhlIGAudG9nZ2xlKClgIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAc2luY2UgOC4wLjBcclxuICAgKi9cclxuICBASW5wdXQoKSBhbmltYXRpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgd2lsbCBjb2xsYXBzZSB0aGUgZWxlbWVudCBvciBzaG93IGl0IG90aGVyd2lzZS5cclxuICAgKi9cclxuICBASW5wdXQoJ25nYkNvbGxhcHNlJykgY29sbGFwc2VkID0gZmFsc2U7XHJcblxyXG4gIEBPdXRwdXQoKSBuZ2JDb2xsYXBzZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjb2xsYXBzZSBlbGVtZW50IGlzIHNob3duLCBhZnRlciB0aGUgdHJhbnNpdGlvbi4gSXQgaGFzIG5vIHBheWxvYWQuXHJcbiAgICpcclxuICAgKiBAc2luY2UgOC4wLjBcclxuICAgKi9cclxuICBAT3V0cHV0KCkgc2hvd24gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29sbGFwc2UgZWxlbWVudCBpcyBoaWRkZW4sIGFmdGVyIHRoZSB0cmFuc2l0aW9uLiBJdCBoYXMgbm8gcGF5bG9hZC5cclxuICAgKlxyXG4gICAqIEBzaW5jZSA4LjAuMFxyXG4gICAqL1xyXG4gIEBPdXRwdXQoKSBoaWRkZW4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLCBjb25maWc6IE5nYkNvbGxhcHNlQ29uZmlnLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uID0gY29uZmlnLmFuaW1hdGlvbjtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkgeyB0aGlzLl9ydW5UcmFuc2l0aW9uKHRoaXMuY29sbGFwc2VkLCBmYWxzZSk7IH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoe2NvbGxhcHNlZH06IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgIGlmICghY29sbGFwc2VkLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgIHRoaXMuX3J1blRyYW5zaXRpb25XaXRoRXZlbnRzKHRoaXMuY29sbGFwc2VkLCB0aGlzLmFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VycyBjb2xsYXBzaW5nIHByb2dyYW1tYXRpY2FsbHkuXHJcbiAgICpcclxuICAgKiBJZiB0aGVyZSBpcyBhIGNvbGxhcHNpbmcgdHJhbnNpdGlvbiBydW5uaW5nIGFscmVhZHksIGl0IHdpbGwgYmUgcmV2ZXJzZWQuXHJcbiAgICogSWYgdGhlIGFuaW1hdGlvbnMgYXJlIHR1cm5lZCBvZmYgdGhpcyBoYXBwZW5zIHN5bmNocm9ub3VzbHkuXHJcbiAgICpcclxuICAgKiBAc2luY2UgOC4wLjBcclxuICAgKi9cclxuICB0b2dnbGUob3BlbjogYm9vbGVhbiA9IHRoaXMuY29sbGFwc2VkKSB7XHJcbiAgICB0aGlzLmNvbGxhcHNlZCA9ICFvcGVuO1xyXG4gICAgdGhpcy5uZ2JDb2xsYXBzZUNoYW5nZS5uZXh0KHRoaXMuY29sbGFwc2VkKTtcclxuICAgIHRoaXMuX3J1blRyYW5zaXRpb25XaXRoRXZlbnRzKHRoaXMuY29sbGFwc2VkLCB0aGlzLmFuaW1hdGlvbik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZDogYm9vbGVhbiwgYW5pbWF0aW9uOiBib29sZWFuKSB7XHJcbiAgICByZXR1cm4gbmdiUnVuVHJhbnNpdGlvbihcclxuICAgICAgICB0aGlzLl96b25lLCB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5nYkNvbGxhcHNpbmdUcmFuc2l0aW9uLFxyXG4gICAgICAgIHthbmltYXRpb24sIHJ1bm5pbmdUcmFuc2l0aW9uOiAnc3RvcCcsIGNvbnRleHQ6IHtkaXJlY3Rpb246IGNvbGxhcHNlZCA/ICdoaWRlJyA6ICdzaG93J319KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3J1blRyYW5zaXRpb25XaXRoRXZlbnRzKGNvbGxhcHNlZDogYm9vbGVhbiwgYW5pbWF0aW9uOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZCwgYW5pbWF0aW9uKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAoY29sbGFwc2VkKSB7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4uZW1pdCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2hvd24uZW1pdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl19